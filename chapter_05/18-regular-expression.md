# 정규표현식(정규식)

문자열에 포함된 특정 문자 조합을 찾기 위해 사용되는 패턴  
사용자로부터 입력받은 데이터가 받고자 하는 데이터 형식과 일치하는지 체크할 때 주로 사용

## 정규식 만드는 방법

> 1\. 정규식 리터럴 슬래시(/)로 감싸기

```javascript
const regexp = /World/;
```

> 2\. RegExp 객체 생성

실행 시점에 컴파일되므로 다른 출처로부터 오는 정보에 따라 패턴을 동적으로 적용해야 하는 경우 사용함

```javascript
const regexp2 = new RegExp("World");
```

## 정규식 함수

> exec

찾고자 하는 문자열 패턴을 찾고 배열을 반환, 실패 시 null 반환

> test

대응되는 문자열이 있는지 검사하고 있으면 true, 없으면 false 반환

> match

대응되는 문자열을 찾아 배열로 반환하는 String 객체 내장 함수  
실패 시 null 반환   
exec와 동일한 기능

> search

대응되는 문자열이 있는지 검사하고, 대응되는 첫번째 문자열의 인덱스를 반환하는 String 객체 내장 함수  
실패 시 -1 반환

> replace

대응되는 문자열이 있는지 검사하고, 다른 문자열로 치환하는 String 객체 내장 함수

> split

대응되는 문자열을 찾고, 찾은 문자열을 기준으로 나누어서 배열로 반환하는 String 객체 내장 함수

```javascript
let str = "Hello World! world!";
const re = /World/;
console.log(re.test(str)); // true
console.log(str.search(re)); // 6
```

## 정규식 특수문자

> 백슬래시(\)

Escape

> ^

입력의 시작 부분  
/^A/ = 문자열이 A로 시작

> $

입력의 끝 부분  
/t$/ = 문자열이 t로 끝남

> \*

직전의 표현식이 0회 이상 반복됨  
/bo\*/ = 문자열에 b를 포함하고 b 직후의 문자로 o가 0회 이상 등장

> \+

직전의 표현식이 1회 이상 반복됨  
/bo+/ = 문자열에 b를 포함하고 b 직후의 문자로 o가 1회 이상 등장

> ?

직전의 표현식이 0회 또는 1회 등장  
/e?le?/ = e가 없어도 되고 있다면 1회(l, el, ele, le를 포함하는지)

> .

단일 문자  
/.n/은 "an apple"에서 "an"에 대응됨

> (x)

포획괄호  
/foo{1,2}/ = 마지막 o에 {1,2}가 적용되어 o가 최소 1회, 최대 2회 등장  
/(foo){1,2}/ = foo 전체에 {1,2}가 적용됨  
/(\d+)(\d{3})/ = 1개 이상의 숫자, 3개의 숫자 패턴  
대응되는 결과를 $1, $2 ... $n과 같은 문법으로 사용 가능  
"23450".replace(/(\d+)(\d{3})/, "$1"+","+"$2")의 결과 = 23,450

> (?:x)
 
비포획괄호  
포획괄호와 사용법은 동일하지만 차이점은 대응되는 결과를 기억하지 않음

> x(?=y)

x 뒤에 y가 뒤따라오는 경우(lookahead)  
/\d+(?=g)/ = 숫자 뒤에 g가 뒤따라오는 경우

> x(?!y)

x 뒤에 y가 없는 경우(negative lookahead)

> x|y

x 또는 y

> {n}

직전의 표현식이 n번 나타나는 부분(n은 양의 정수)  
/e{2}/ = e가 2회 등장  
처음 나타나는 패턴에만 대응됨

> {n,m}

직전의 표현식이 최소 n회, 최대 m회 등장(n과 m은 n<=m인 양의 정수)  
/e{1,3}/ = e가 최소 1회, 최대 3회 등장  
처음 나타나는 패턴에만 대응됨

> [xyz]

문자셋  
하이픈(-)으로 문자의 범위 지정 가능  
[a-d] == [abc]

> [^xyz]

부정 문자셋

> [\b]

백스페이스

> \b

첫 문자와 종료 문자(문자열에 있는 단어의 경계)  
/\bm/ = m으로 시작하는 단어  
/oon\b/ = oon으로 끝나는 단어

> \B

단어의 경계가 아닌 부분

> \d

숫자 문자  
/\d/ == [0-9]

> \D

숫자가 아닌 문자  
/\D/ == [^0-9]

> \f

폼피드 문자(U+000C)

> \n

줄바꿈 문자(U+000A)

> \r

엔터키 문자

> \s

하나의 공백 문자  
/\s\w\*/ = foo bar의 bar에 대응됨

> \S

공백 문자가 아닌 문자

> \t

탭(U+0009) 문자

> \v

수직 탭(U+000B) 문자

> \w

밑줄 문자, 숫자, 영문 문자  
/\w/ == [A-Za-z0-9_]

> \W

밑줄 문자, 숫자, 영문 문자가 아닌 문자  
/\w/ == [^a-za-z0-9_]

> \n

새로운 줄(new line)

> \0

널(U+0000)문자

> \xhh

16진수 hh

> \uhhh

유니코드 문자 16진수 hhh

## 정규식 플래그

> g

전역 검색 대응되는 문자 전부 검색

> i

대소문자 구분 없는 검색

> m

다중 행 검색

## 정규식이 자주 사용되는 사례

> 핸드폰 번호가 올바른 형식인지 체크하는 정규식

```javascript
const regexp_mobile = /^(010)-\d{4}-\d{4}$/;
console.log(regexp_mobile.test("010-3124-1234")); // true
```

> 이메일 주소가 올바른 형식인지 체크하는 정규식

```javascript
const regexp_email = /^([a-z]+\d*)+(\.?\w+)+@\w+(\.\w{2,3})+$/;
console.log(regexp_email.test("sookyeong.dev@gmail.com")); // true
```

반드시 알파벳 소문자로 시작하고, 숫자는 0회 이상인 패턴 1번 이상  
점(.)은 없거나 1번만 사용할 수 있고 뒤에 하나 이상의 문자가 옴  
반드시 @가 있고 뒤에 하나 이상의 문자가 옴  
점(.)과 2~3개의 문자가 1회 이상 반복된 후 종료됨
